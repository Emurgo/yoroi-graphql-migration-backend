import { errMsgs, UtilEither, getAddressesByType } from "../utils";

import { TransactionFrag } from "../Transactions/types";

import { mapTxRowsToTransactionFrags } from "../utils/mappers";

import { Pool } from "pg";

/**
  Everything else in this repo is using graphql, so why psql here?
  Hasura and the rest of the GraphQL start are _slow_ for this sort of thing.
  The psql query generated by Hasura for the equiv GraphQL does several layers
  of lateral joins.  On my machine, such queries can take as long as 41s to run.
  This SQL is fast, averaging about 10ms (though, clearly, the time scales poorly
  with the number of results, as you can see by the subqueries in the select clause.
  As we anticipate cardano-graphql being able to handle this in the future, I have
  left the interface to match what graphql would do.  For posterity's sake, I have
  also left the original GraphQL query in this file. 
  Beware! The GraphQL query never passed tests, and doesn't pull blockindex/tx_ordinal/tx_index.
**/
const askTransactionSqlQuery = `
  with
    hashes as (
      select distinct hash
      from (
            ${/* 1.1) Get all inputs for the transaction */ ""}

            select tx.hash as hash
            FROM tx

            JOIN tx_in 
              ON tx_in.tx_in_id = tx.id

            ${
              /**
              note: input table doesn't contain addresses directly
              so to check for all inputs that use address X
              we have to check the address for all outputs that occur in the input table
            **/ ""
            }
            JOIN tx_out source_tx_out 
              ON tx_in.tx_out_id = source_tx_out.tx_id 
             AND tx_in.tx_out_index::smallint = source_tx_out.index::smallint

            JOIN tx source_tx 
              ON source_tx_out.tx_id = source_tx.id

            WHERE source_tx_out.address = ANY(($1)::varchar array)
               OR source_tx_out.payment_cred = ANY(($6)::bytea array)

          UNION

          ${/* 1.2) Get all collateral inputs for the transaction */ ""}

          select tx.hash as hash
            FROM tx

            JOIN collateral_tx_in 
              ON collateral_tx_in.tx_in_id = tx.id

            ${
              /**
              note: input table doesn't contain addresses directly
              so to check for all inputs that use address X
              we have to check the address for all outputs that occur in the input table
            **/ ""
            }
            JOIN tx_out source_tx_out 
              ON collateral_tx_in.tx_out_id = source_tx_out.tx_id 
            AND collateral_tx_in.tx_out_index::smallint = source_tx_out.index::smallint

            JOIN tx source_tx 
              ON source_tx_out.tx_id = source_tx.id

            WHERE source_tx_out.address = ANY(($1)::varchar array)
              OR source_tx_out.payment_cred = ANY(($6)::bytea array)

          UNION
            ${/* 2) Get all outputs for the transaction */ ""}
            select tx.hash as hash
            from tx

            JOIN tx_out
              on tx.id = tx_out.tx_id

            where tx_out.address = ANY(($1)::varchar array)
              or tx_out.payment_cred = ANY(($6)::bytea array)

          UNION
            ${/* 3) Get all certificates for the transaction */ ""}
            select tx.hash as hash
            from tx 

            JOIN combined_certificates as certs 
              on tx.id = certs."txId" 
            where
              (
                certs."formalType" in ('CertRegKey', 'CertDeregKey','CertDelegate')
                and certs."stakeCred" = any(
                  ${
                    /* stakeCred is encoded as a string, so we have to convert from a byte array to a hex string */ ""
                  }
                  (SELECT array_agg(encode(addr, 'hex')) from UNNEST($7::bytea array) as addr)::varchar array
                )
              ) or (
                ${
                  /* note: PoolRetirement only contains pool key hash, so no way to map it to an address */ ""
                }
                certs."formalType" in ('CertRegPool')
                and certs."poolParamsRewardAccount" = any(
                  ${
                    /* poolParamsRewardAccount is encoded as a string, so we have to convert from a byte array to a hex string */ ""
                  }
                  (SELECT array_agg(encode(addr, 'hex')) from UNNEST($7::bytea array) as addr)::varchar array
                )
              )

          UNION
            ${/* 4) Get all withdrawals for the transaction */ ""}

            select tx.hash as hash
            from tx

            JOIN withdrawal as w
            on tx.id = w."tx_id"

            JOIN stake_address as addr
            on w.addr_id = addr.id

            where addr.hash_raw = any(($7)::bytea array)
           ) hashes
    )
  select tx.hash
       , tx.fee
       , tx.valid_contract
       , tx.script_size
       , tx_metadata_agg(tx.id) as metadata
       , tx.block_index as "txIndex"
       , block.block_no as "blockNumber"
       , block.hash as "blockHash"
       , block.epoch_no as "blockEpochNo"
       , block.slot_no as "blockSlotNo"
       , block.epoch_slot_no as "blockSlotInEpoch"
       , block_era_from_vrf_key(vrf_key) as "blockEra"
       , block.time at time zone 'UTC' as "includedAt"
       , in_addr_val_pairs(tx.hash) as "inAddrValPairs"
        , collateral_in_addr_val_pairs(tx.hash) as "collateralInAddrValPairs"
       , out_addr_val_pairs(tx.id, tx.hash) as "outAddrValPairs"
       , withdraws_agg(tx.id) as withdrawals
       , certificates_agg(tx.id) as certificates
                            
  from tx

  JOIN hashes
    on hashes.hash = tx.hash

  JOIN block
    on block.id = tx.block_id

  LEFT JOIN pool_metadata_ref 
    on tx.id = pool_metadata_ref.registered_tx_id 

  where 
        ${/* is within untilBlock (inclusive) */ ""}
        block.block_no <= $2
        and (
          ${/* Either: */ ""}
          ${/* 1) comes in block strict after the "after" field */ ""}
          block.block_no > $3
            or
          ${
            /* 2) Is in the same block as the "after" field, but is tx that appears afterwards */ ""
          }
          (block.block_no = $3 and tx.block_index > $4)
        ) 

  order by block.time asc, tx.block_index asc
  limit $5;
`;

export const askTransactionHistory = async (
  pool: Pool,
  limit: number,
  addresses: string[],
  after: {
    blockNumber: number;
    txIndex: number;
  },
  untilNum: number
): Promise<UtilEither<TransactionFrag[]>> => {
  const addressTypes = getAddressesByType(addresses);
  const ret = await pool.query(askTransactionSqlQuery, [
    [...addressTypes.legacyAddr, ...addressTypes.bech32],
    untilNum,
    after.blockNumber,
    after.txIndex,
    limit,
    addressTypes.paymentCreds,
    addressTypes.stakingKeys,
  ]);
  const txs = mapTxRowsToTransactionFrags(ret.rows);
  return { kind: "ok", value: txs };
  //if('data' in ret && 'data' in ret.data && 'transactions' in ret.data.data)
  //    return {'kind':'ok', value:ret.data.data.transactions};
  //else
  //    return {'kind':'error', errMsg:'TxsHistory, could not understand graphql response'};
};

export interface BlockNumByTxHashFrag {
  block: BlockByTxHashFrag;
  hash: string;
  blockIndex: number; // this is actually the index of the transaction in the block
}
interface BlockByTxHashFrag {
  hash: string;
  number: number;
}

const askBlockNumByTxHashQuery = `
  SELECT "tx"."hash" AS "hash", "tx"."block_index" as "blockIndex", "Block"."block_no" AS "blockNumber", "Block"."hash" AS "blockHash"
  FROM "tx"
  LEFT JOIN "block" "Block" ON "tx"."block_id" = "Block"."id"
  WHERE "tx"."hash"=decode($1, 'hex')
`;

export const askBlockNumByTxHash = async (
  pool: Pool,
  hash: string | undefined
): Promise<UtilEither<BlockNumByTxHashFrag>> => {
  if (!hash) return { kind: "error", errMsg: errMsgs.noValue };

  try {
    const res = await pool.query(askBlockNumByTxHashQuery, [hash]);
    return {
      kind: "ok",
      value: {
        block: {
          hash: res.rows[0].blockHash.toString("hex"),
          number: res.rows[0].blockNumber,
        },
        hash: res.rows[0].hash.toString("hex"),
        blockIndex: res.rows[0].blockIndex,
      },
    };
  } catch (err: any) {
    const errString = err.stack + "";
    return { kind: "error", errMsg: "askBlockNumByTxHash error: " + errString };
  }
};

const askBlockNumByHashQuery = `
  SELECT "block"."block_no" AS "blockNumber"
  FROM "block"
  WHERE "block"."hash"=decode($1, 'hex')
`;

export const askBlockNumByHash = async (
  pool: Pool,
  hash: string
): Promise<UtilEither<number>> => {
  if (!hash) return { kind: "error", errMsg: errMsgs.noValue };

  try {
    const res = await pool.query(askBlockNumByHashQuery, [hash]);
    if (res.rows.length === 0)
      return { kind: "error", errMsg: errMsgs.noValue };
    return {
      kind: "ok",
      value: res.rows[0].blockNumber,
    };
  } catch (err: any) {
    const errString = err.stack + "";
    return { kind: "error", errMsg: "askBlockNumByHash error: " + errString };
  }
};
