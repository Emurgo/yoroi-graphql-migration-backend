import {
  errMsgs,
  UtilEither,
  extractAssets,
  getAddressesByType,
} from "../utils";

import {
  rowToCertificate,
  BlockEra,
  BlockFrag,
  Certificate,
  TransInputFrag,
  TransOutputFrag,
  TransactionFrag,
  Asset,
} from "../Transactions/types";

import {
  GeneralTransactionMetadata,
  TransactionMetadatum,
  BigNum,
} from "@emurgo/cardano-serialization-lib-nodejs";

import { Pool } from "pg";

/**
  Everything else in this repo is using graphql, so why psql here?
  Hasura and the rest of the GraphQL start are _slow_ for this sort of thing.
  The psql query generated by Hasura for the equiv GraphQL does several layers
  of lateral joins.  On my machine, such queries can take as long as 41s to run.
  This SQL is fast, averaging about 10ms (though, clearly, the time scales poorly
  with the number of results, as you can see by the subqueries in the select clause.
  As we anticipate cardano-graphql being able to handle this in the future, I have
  left the interface to match what graphql would do.  For posterity's sake, I have
  also left the original GraphQL query in this file. 
  Beware! The GraphQL query never passed tests, and doesn't pull blockindex/tx_ordinal/tx_index.
**/
// ToDo: remove the + 0 and + '0 seconds'::interval
/* these things are only needed because we created these tables with indexes in these
columns assuming it would be faster, but in fact it is not, so we do these useless math
in order to bypass the index. we should drop the indexes and remove these from the query */
const askTransactionSqlQuery = `--sql
SELECT tx.hash,
  tx.fee,
  tx.valid_contract,
  tx.script_size,
  tx.metadata,
  tx.block_index "txIndex",
  tx.block__block_no as "blockNumber",
  tx.block__hash as "blockHash",
  tx.block__epoch_no as "blockEpochNo",
  tx.block__slot_no as "blockSlotNo",
  tx.block__epoch_slot_no as "blockSlotInEpoch",
  tx.block__block_no as "blockNumber",
  case
      when tx.block__vrf_key is null then 'byron'
      else 'shelley' end
  as "blockEra",
  tx.block__time at time zone 'UTC' as "includedAt",
  tx."inAddrValPairs",
  tx."collateralInAddrValPairs",
  tx."outAddrValPairs",
  tx."withdrawals",
  tx."certificates"
FROM history_tx tx
    JOIN history_addr addr on tx.id = addr.tx_id
WHERE addr.address = ANY($1::text array)
    AND block__block_no + 0 <= $2
    AND (
        block__block_no + 0 > $3
        OR (
            block__block_no + 0 = $3
            AND block_index + 0 > $4
        )
    )
ORDER BY block__time + '0 seconds'::interval ASC, block_index asc
limit $5
`;

const MAX_INT = "2147483647";

function buildMetadataObj(
  metadataMap: null | Record<string, string>
): null | string {
  if (metadataMap == null) return null;
  const metadataWasm = GeneralTransactionMetadata.new();
  for (const key of Object.keys(metadataMap)) {
    const keyWasm = BigNum.from_str(key);
    // the cbor inserted into SQL is not the full metadata for the transaction
    // instead, each row is a CBOR map with a single entry <transaction_metadatum_label, transaction_metadatum>
    const singletonMap = TransactionMetadatum.from_bytes(
      Buffer.from(
        // need to cutoff the \\x prefix added by SQL
        metadataMap[key].substring(2),
        "hex"
      )
    );
    const map = singletonMap.as_map();
    const keys = map.keys();
    for (let i = 0; i < keys.len(); i++) {
      const cborKey = keys.get(i);
      const datumWasm = map.get(cborKey);
      metadataWasm.insert(keyWasm, datumWasm);
      datumWasm.free();
      cborKey.free();
    }
    keyWasm.free();
    singletonMap.free();
    map.free();
    keys.free();
  }
  const result = Buffer.from(metadataWasm.to_bytes()).toString("hex");
  metadataWasm.free();

  return result;
}

export const askTransactionHistory = async (
  pool: Pool,
  limit: number,
  addresses: string[],
  after: {
    blockNumber: number;
    txIndex: number;
  },
  untilNum: number
): Promise<UtilEither<TransactionFrag[]>> => {
  const addressTypes = getAddressesByType(addresses);
  const preciseUntilBlock: number = await pool.query(`--sql
    select max(block__block_no) block_no from history_tx`)
    .then(r => r.rows[0].block_no);

  if (untilNum > preciseUntilBlock) {
    untilNum = preciseUntilBlock;
  }

  const allAddresses = [
    ...addressTypes.legacyAddr,
    ...addressTypes.bech32,
    ...addressTypes.paymentCreds.map(x => x.replace("\\x", "")),
    ...addressTypes.stakingKeys.map(x => x.replace("\\x", "")),
  ];

  const ret = await pool.query(askTransactionSqlQuery, [
    allAddresses,
    untilNum,
    after.blockNumber,
    after.txIndex,
    limit,
  ]);

  const txs = ret.rows.map((row: any): TransactionFrag => {
    const inputs = row.inAddrValPairs
      ? row.inAddrValPairs.map(
          (obj: any): TransInputFrag => ({
            address: obj.f1,
            amount: obj.f2.toString(),
            id: obj.f3.concat(obj.f4.toString()),
            index: obj.f4,
            txHash: obj.f3,
            assets: extractAssets(obj.f5),
          })
        )
      : [];
    const collateralInputs = row.collateralInAddrValPairs
      ? row.collateralInAddrValPairs.map(
          (obj: any): TransInputFrag => ({
            address: obj.f1,
            amount: obj.f2.toString(),
            id: obj.f3.concat(obj.f4.toString()),
            index: obj.f4,
            txHash: obj.f3,
            assets: extractAssets(obj.f5),
          })
        )
      : [];
    const outputs = row.outAddrValPairs
      ? row.outAddrValPairs.map(
          (obj: any): TransOutputFrag => ({
            address: obj.f1,
            amount: obj.f2.toString(),
            dataHash: obj.f3?.toString() ?? null,
            assets: extractAssets(obj.f4),
          })
        )
      : [];
    const withdrawals: TransOutputFrag[] = row.withdrawals
      ? row.withdrawals.map(
          (obj: any): TransOutputFrag => ({
            address: obj.f1,
            amount: obj.f2.toString(),
            dataHash: null,
            assets: [] as Asset[],
          })
        )
      : [];
    const certificates =
      row.certificates !== null
        ? row.certificates
            .map(rowToCertificate)
            .filter((i: Certificate | null) => i !== null)
        : [];
    const blockFrag: BlockFrag = {
      number: row.blockNumber,
      hash: row.blockHash.replace("\\x", ""),
      epochNo: row.blockEpochNo,
      slotNo: row.blockSlotInEpoch,
    };

    return {
      hash: row.hash,
      block: blockFrag,
      validContract: row.valid_contract,
      scriptSize: row.script_size,
      fee: row.fee.toString(),
      metadata: buildMetadataObj(row.metadata),
      includedAt: row.includedAt,
      inputs: inputs,
      collateralInputs: collateralInputs,
      outputs: outputs,
      ttl: MAX_INT, // https://github.com/input-output-hk/cardano-db-sync/issues/212
      blockEra: row.blockEra === "byron" ? BlockEra.Byron : BlockEra.Shelley,
      txIndex: row.txIndex,
      withdrawals: withdrawals,
      certificates: certificates,
    };
  });

  return { kind: "ok", value: txs };
  //if('data' in ret && 'data' in ret.data && 'transactions' in ret.data.data)
  //    return {'kind':'ok', value:ret.data.data.transactions};
  //else
  //    return {'kind':'error', errMsg:'TxsHistory, could not understand graphql response'};
};

export interface BlockNumByTxHashFrag {
  block: BlockByTxHashFrag;
  hash: string;
  blockIndex: number; // this is actually the index of the transaction in the block
}
interface BlockByTxHashFrag {
  hash: string;
  number: number;
}

const askBlockNumByTxHashQuery = `
  SELECT "tx"."hash" AS "hash", "tx"."block_index" as "blockIndex", "Block"."block_no" AS "blockNumber", "Block"."hash" AS "blockHash"
  FROM "tx"
  LEFT JOIN "block" "Block" ON "tx"."block_id" = "Block"."id"
  WHERE "tx"."hash"=decode($1, 'hex')
`;

export const askBlockNumByTxHash = async (
  pool: Pool,
  hash: string | undefined
): Promise<UtilEither<BlockNumByTxHashFrag>> => {
  if (!hash) return { kind: "error", errMsg: errMsgs.noValue };

  try {
    const res = await pool.query(askBlockNumByTxHashQuery, [hash]);
    return {
      kind: "ok",
      value: {
        block: {
          hash: res.rows[0].blockHash.toString("hex"),
          number: res.rows[0].blockNumber,
        },
        hash: res.rows[0].hash.toString("hex"),
        blockIndex: res.rows[0].blockIndex,
      },
    };
  } catch (err: any) {
    const errString = err.stack + "";
    return { kind: "error", errMsg: "askBlockNumByTxHash error: " + errString };
  }
};

const askBlockNumByHashQuery = `
  SELECT "block"."block_no" AS "blockNumber"
  FROM "block"
  WHERE "block"."hash"=decode($1, 'hex')
`;

export const askBlockNumByHash = async (
  pool: Pool,
  hash: string
): Promise<UtilEither<number>> => {
  if (!hash) return { kind: "error", errMsg: errMsgs.noValue };

  try {
    const res = await pool.query(askBlockNumByHashQuery, [hash]);
    if (res.rows.length === 0)
      return { kind: "error", errMsg: errMsgs.noValue };
    return {
      kind: "ok",
      value: res.rows[0].blockNumber,
    };
  } catch (err: any) {
    const errString = err.stack + "";
    return { kind: "error", errMsg: "askBlockNumByHash error: " + errString };
  }
};
